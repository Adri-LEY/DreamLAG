<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.glTFFileLoader.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.waterMaterial.js"></script>




    </head>

   <body>

	<canvas id="renderCanvas"></canvas>

	<script>

        // DracoDecoder.DefaultConfiguration = {
        //     wasmUrl: "/babylon-draco-files/draco_wasm_wrapper_gltf.js",
        //     wasmBinaryUrl: "/babylon-draco-files/draco_decoder_gltf.wasm",
        //     fallbackUrl: "/babylon-draco-files/draco_decoder_gltf.js",
        // };

        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        const createScene = async function () {
            // This creates a basic Babylon Scene object (non-mesh)
            const scene = new BABYLON.Scene(engine);
            scene.collisionsEnabled = true;
            // scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
            // This creates and positions a free camera (non-mesh)
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            
            // // This targets the camera to scene origin
            // camera.setTarget(BABYLON.Vector3.Zero());
            // // This attaches the camera to the canvas
            // camera.attachControl(canvas, true);
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;
            // Our built-in 'sphere' shape.
            // const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, scene);
            // Move the sphere upward 1/2 its height
            // sphere.position.y = 1;
            // Our built-in 'ground' shape.
            
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
            //scene.createOrUpdateSelectionOctree();

            // scene.gravity = new BABYLON.Vector3(0, -0.1, 0);

            // Créer le WaterMaterial
            const waterMaterial = new BABYLON.WaterMaterial("waterMaterial", scene, new BABYLON.Vector2(512, 512));
            waterMaterial.bumpTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/waterbump.png", scene); // texture de vague (bump)

            // Paramètres personnalisables
            waterMaterial.windForce =2;
            waterMaterial.waveHeight = 0,1;
            waterMaterial.bumpHeight = 0.1;
            waterMaterial.waveLength = 0.1;
            waterMaterial.colorBlendFactor = 0; // 0 pour privilégier la couleur définie
            waterMaterial.waterColor = new BABYLON.Color3(0.0, 0.3, 0.4);

            // Pour des reflets et réfractions réalistes, définis la caméra et éventuellement un skybox
            //waterMaterial.addToRenderList(skybox);


            var animatedIsland = await BABYLON.SceneLoader.ImportMeshAsync("", "GameElements/Islands/Island1/assets/", "FirstIsland.gltf", scene)
                console.log("Modèle chargé :", animatedIsland.meshes);

            
                // meshes2 = meshes[0];
                const camPos = scene.activeCamera.position;
                    
                animatedIsland.meshes.forEach(mesh => {

                    console.log(mesh.name);

                    if (mesh.name === "InvisibleGround" && mesh.isVerticesDataPresent("position")) {
                            
                            
                        if (mesh instanceof BABYLON.Mesh) {
                            console.log("FOUND!! - c'est un Mesh");
                            mesh.setParent(null); // Détache l'objet de son parent
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh,
                                BABYLON.PhysicsImpostor.MeshImpostor,
                                { mass: 0, restitution: 0.3 }, scene);
                            mesh.checkCollisions = true;
                            // mesh.applyGravity = false;
                            mesh.isVisible=false;
                            console.log("Mesh Impostor :", mesh.physicsImpostor);
                        } else {
                            console.warn("L'objet InvisibleGround n'est pas un Mesh mais un", mesh.getClassName());
                        }
                    }  

                    if(mesh.name==="WaterMesh" && mesh.isVerticesDataPresent("position")){
                        mesh.material = waterMaterial;
                    }


                    });

                    
            
                let importedCamera = scene.getCameraByName("Camera.001");
                console.log(importedCamera);
                // importedCamera.checkCollisions=true;
                // importedCamera.applyGravity = true;
                camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

                if (importedCamera) {
                    console.log("Caméra importée trouvée !");
                    // Activer la caméra importée au lieu de la FreeCamera
                    scene.activeCamera = importedCamera;
                    importedCamera.attachControl(canvas, true);
                } else {
                    console.log("⚠️ Aucune caméra importée trouvée, utilisez une FreeCamera.");
                }

                
            

            // Supposons que "island" est ton mesh principal (complexe visuellement)
            


            var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 10, segments: 32}, scene);

            // Move the sphere upward 1/2 its height
            sphere.position.x = camera.position.x+100
            sphere.position.y = camera.position.y+200
            sphere.position.z = camera.position.z;
            sphere.applyGravity = true;
            // sphere.checkCollisions=true;
            sphere.ellipsoid =  new BABYLON.Vector3(0.5, 1, 0.5);

            sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere,
            BABYLON.PhysicsImpostor.SphereImpostor,
            { mass: 1, restitution: 0.5 }, scene); 
            console.log("hello");

            // var sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 10, segments: 32}, scene);

            // // Move the sphere upward 1/2 its height
            // sphere2.position.x = camera.position.x+100
            // sphere2.position.y = camera.position.y+450
            // sphere2.position.z = camera.position.z;
            // sphere2.applyGravity = true;
            // // sphere.checkCollisions=true;
            // sphere2.ellipsoid =  new BABYLON.Vector3(0.5, 1, 0.5);

            // sphere2.physicsImpostor = new BABYLON.PhysicsImpostor(sphere2,
            // BABYLON.PhysicsImpostor.SphereImpostor,
            // { mass: 1, restitution: 0.5 }, scene); 
            // console.log("hello");

            // Application de la physique à la sphère
            

            console.log("sphere Position : "+sphere.getAbsolutePosition());

            return scene;

            
        };
        
        createScene().then(scene => {
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
	</script>

   </body>

</html>